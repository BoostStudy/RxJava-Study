### 람다식

- 함수형 인터페이스를 구현하기위해 도입한 표현식
    - 구현해야하는 메서드가 **1개**
        - kotlin 에서는 SAM (Single Abstract Method) 를 이용
    - JAVA 8 부터 도입
    - JAVA 8 이전 버전에서는 Retrolambda 라는 **백포트**를 이용해 사용 가능

> [!note] 백포트
> 상위 버전의 기능을 하위 버전에 반영해주는 것

### Rx에서 제공하는 인터페이스

#### Function/Predicate

- 인자 O
- 반환 O  
  |인터페이스|반환값|메서드|
  |---|---|---|
  | Function\<T, R\> | R | apply(t: T) |
  | Predicate\<T\> | boolean | test(t: T) |

#### BooleanSupplier

- 인자 X
- 반환 O  
  |인터페이스|반환값|메서드|
  |---|---|---|
  | BooleanSupplier | boolean | getAsBoolean() |

#### Action/Consumer

- 어떤 부가 작용이 발생하는 메서드
- 반환 X  
  |인터페이스|반환값|메서드|
  |---|---|---|
  | Action | 없음 | run() |
  | Consumer\<T\> | 없음 | accept(t: T) |\\

#### Cancellable

- 취소처리를 구현하는데 사용
- 반환 X
- 인자 X  
  |인터페이스|반환값|메서드|
  |---|---|---|
  | Cancellable | 없음 | cancel() |

### 람다식과 익명 클래스의 차이

- **this** 의 대상이 다름
- 람다식
    - **람다식을 구현한 클래스**의 인스턴스
- 익명 클래스
    - **구현한 익명 클래스**의 인스턴스

### 비동기 처리

>작업의 처리가 끝나지 않고 다음 작업을 실행

- 싱글 스레드에서는 작업이 순차적으로 진행
- DB, 네트워크 작업시에는 CPU를 사용하지 않는 순간 이 있기 때문에 기다리기 보다 다른 작업을 하는게 효율적
- 스레드 생성 작업자체가 부하가 걸리는 작업이라 작은 작업은 순차처리하는게 이득

### 비동기 처리시 주의할 점

#### 메모리와 캐시

- 클래스 필드 값과 실제 메모리가 가리키는 값이 동일하지 않을 수 있다
    - 필드가 다루는 값은 메모리에서 캐시된 값
    - 나중에 적절한 시점에 실제 메모리에 값을 변경
    - 캐시 값은 **쓰레드 별**로 존재

#### 원자성

- **volatile**
    - 실제 메모리의 최신 값을 받을 수 있다
    - 업데이트시 원자성을 보장하지 않는다
- **Atomic**
    - 원자성을 보장하는 클래스
    - 자신의 변경 처리에서만 원자성을 보장
- **synchronized**
    - 자신의 스레드가 해당 블록을 처리하는 도중에 다른 스레드에서 접근하는 것을 막는다
    - Lock 객체를 이용하고 해당 객체를 가지고 있으면 해당 블록에서 작업을 실행할 수 있다.

### 비동기 처리 대응 방안

#### final 제한자와 불변 객체

- 비동기처리할때 가변 필드나 객체를 다루면 스레드에 의해 다른 캐시 값을 가질 위험이 있다
    - 변수의 재할당이나 상태를 변경하지 못하게함